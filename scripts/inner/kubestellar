#!/usr/bin/env bash
# Copyright 2023 The KubeStellar Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Usage: $0 (init or start or stop | -v)

# Purpose: control whether the controllers are running, setting up the ESPW if necessary.. The following components are created:
#           (a) 1 kcp workspace: edge service provider workspace (espw)
#           (b) 3 kubestellar controllers: kubestellar-where-resolver, mailbox-controller and placement-translator

# Assumption: kcp server is running.

# Requirements:
#    Download KubeStellar binaries
#    KubeStellar controller binaries are on $PATH.
#    kubectl is configured to talk to kcp server with high privilege

bindir=$(dirname $(realpath "${BASH_SOURCE[0]}"))

set -e

subcommand=""
verbosity=0
verbdir="&> /dev/null"
xflag=""
remove=0
cleanup=0
espw_name="espw"
log_folder=$(pwd)/kubestellar-logs
local_kcp=true
imws="root:imw1"
wmws="root:wmw1"

function echoerr() {
   echo "ERROR: $1" >&2
}

function create_space() { # usage: space_name
    space_name=$1
    kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} create -f - <<EOF
apiVersion: space.kubestellar.io/v1alpha1
kind: Space
metadata:
  name: $space_name
  namespace: "${PROVIDER_NAMESPACE}"
spec:
  SpaceProviderDescName: "${PROVIDER_NAME}"
  Type: "managed"
EOF
    echo "Waiting for space $space_name to get into the Ready phase."
    until [ "$(kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n ${PROVIDER_NAMESPACE} -o yaml | grep Ready)" != "" ]; do
        sleep 1
    done
}

# TODO: caching support - the kubeconfig file could already be in the kubeconfig directory.
function get_kubeconfig_file() { # usage: space_name provider_namespace
    space_name="$1"
    provider_namespace="$2"
    if [ "$IN_CLUSTER" == "true" ] ; then
        secret_name=`kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n $provider_namespace -o jsonpath='{$.status.inClusterSecretRef.name}'`
        secret_namespace=`kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n $provider_namespace -o jsonpath='{$.status.inClusterSecretRef.namespace}'`
    else
        secret_name=`kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n $provider_namespace -o jsonpath='{$.status.externalClusterSecretRef.name}'`
        secret_namespace=`kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n $provider_namespace -o jsonpath='{$.status.externalClusterSecretRef.namespace}'`
    fi
    kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get secret $secret_name -n $secret_namespace -o jsonpath='{$.data.kubeconfig}' | base64 -d | base64 -d > ${KUBECONFIG_DIR}/${provider_namespace}-${space_name}
}

function create_space_if_needed_and_get_config() { # usage: space_name
    space_name="$1"
    if kubectl --kubeconfig ${SPACE_MANAGER_KUBECONFIG} get space $space_name -n ${PROVIDER_NAMESPACE} 2>&1 | grep "not found" ; then
        create_space $space_name
    fi
    get_kubeconfig_file $space_name ${PROVIDER_NAMESPACE} 
} 
 
function run_kubectl_in_space() { # usage: space_name kubectl_cmd
    space_name="$1"
    cmd="$2"
    kubeconfig_path="${KUBECONFIG_DIR}/${PROVIDER_NAMESPACE}-$space_name"
    KUBECONFIG=$kubeconfig_path kubectl $cmd
}

# current space at start does not matter, is ESPW on return
function ensure_espw() {
    create_space_if_needed_and_get_config ${espw_name}
    run_kubectl_in_space ${espw_name} "apply -f \"$bindir/../config/exports\""
    echo "Finished populating the espw with kubestellar apiexports"
}

function ensure_imws() {
    while IFS=',' read -ra items; do
        for i in "${items[@]}"; do
            if [ "$i" == "" ] ; then
                continue
            fi
            imw=${i#"root:"}
            echo "Ensuring IMW: $imw"
            create_space_if_needed_and_get_config ${imw}
            if ! run_kubectl_in_space $imw "get apibinding edge.kubestellar.io" ; then # &> /dev/null; then
                run_kubectl_in_space $imw "kcp bind apiexport root:espw:edge.kubestellar.io"
            fi
        done
    done <<< "$1"
}


function ensure_wmws() {
    while IFS=',' read -ra items; do
        for i in "${items[@]}"; do
            if [ "$i" == "" ] ; then
                continue
            fi
            wmw=${i#"root:"}
            echo "Ensuring WMW: $wmw"
            ${bindir}/kubectl-kubestellar-ensure-wmw $wmw $xflag --with-kube true &> /dev/null
        done
    done <<< "$1"
}


while (( $# > 0 )); do
    case "$1" in
    (start|stop|init)
        subcommand=$1;;
    (--log-folder)
        if (( $# > 1 ));
        then { log_folder="$2"; shift; }
        else { echo "$0: missing log folder" >&2; exit 1; }
        fi;;
    (--local-kcp)
        if (( $# > 1 ));
        then { local_kcp="$2"; shift; }
        else { echo "$0: missing log folder" >&2; exit 1; }
        fi;;
    (--verbose|-V)
        verbosity=1
	verbdir="";;
    (--ensure-imw)
        if (( $# > 1 ));
        then { imws="$2"; shift; }
        else { echo "$0: missing comma separated list of IMWs" >&2; exit 1; }
        fi;;
    (--ensure-wmw)
        if (( $# > 1 ));
        then { wmws="$2"; shift; }
        else { echo "$0: missing comma separated list of WMWs" >&2; exit 1; }
        fi;;
    (-X)
        xflag="-X"
        set -x;;
    (-h|--help)
        echo "Usage: $0 [init | start | stop] [--log-folder log_folder] [--local-kcp bool] [--ensure-imw imw-list] [--ensure-wmw wmw-list] [--provider-name provider-name] [-V|--verbose] [-X]"
        exit 0;;
    (-*)
        echo "$0: unknown flag" >&2 ; exit 1;
        exit 1;;
    (*)
        echo "$0: unknown positional argument" >&2; exit 1;
        exit 1;;
    esac
    shift
done
if [ "$PROVIDER_NAME" == "" ]; then
    PROVIDER_NAME="default"
    export PROVIDER_NAME
fi
if [ "$PROVIDER_NAMESPACE" == "" ]; then
    PROVIDER_NAMESPACE=spaceprovider-${PROVIDER_NAME}
    export PROVIDER_NAMESPACE
fi
if [ "$KUBECONFIG_DIR" == "" ]; then
    KUBECONFIG_DIR="temp-space-config"
    export KUBECONFIG_DIR
fi
if [ "$SPACE_MANAGER_KUBECONFIG" == "" ]; then
    SPACE_MANAGER_KUBECONFIG="${KUBECONFIG_DIR}/config"
    export SPACE_MANAGER_KUBECONFIG
fi
if [ "$IN_CLUSTER" == "" ]; then
    IN_CLUSTER=true
    export IN_CLUSTER
fi
echo "KUBECONFIG_DIR=${KUBECONFIG_DIR}"
echo "SPACE_MANAGER_KUBECONFIG=${SPACE_MANAGER_KUBECONFIG}"
echo "PROVIDER_NAME=${PROVIDER_NAME}"
echo "PROVIDER_NAMESPACE=${PROVIDER_NAMESPACE}"
echo "IN_CLUSTER=${IN_CLUSTER}"

if [ "$subcommand" == "" ]; then
    echo "$0: missing a subcommand" >&2
    exit 1
fi

case "$local_kcp" in
    (true|false) ;;
    (*) echo "$0: --local-kcp must be given 'true' or 'false', not '${local_kcp}'" >&2
	exit 1;;
esac


# Check if a given process name is running
process_running() {
  SERVICE="$1"
  if pgrep -f "$SERVICE" >/dev/null
  then
      echo "running"
  else
      echo "stopped"
  fi
}

function create_or_replace() { # usage: filename
    filename="$1"
    kind=$(grep kind: "$filename" | head -1 | awk '{ print $2 }')
    name=$(grep name: "$filename" | head -1 | awk '{ print $2 }')
    if kubectl get "$kind" "$name" &> /dev/null
    then eval kubectl replace -f "$filename" $verbdir
    else eval kubectl create -f "$filename" $verbdir
    fi
}

# current ws at start does not matter, is is root:compute on return
function ensure_root_compute_configd() {
    ( cd ${bindir}/../config/kube/exports/namespaced
      # Some are too big to `kubectl apply`
      for rsfn in apiresourceschema-*.yaml; do
	  create_or_replace $rsfn
      done
      for refn in apiexport-*.yaml; do
	  eval kubectl apply -f "$refn" $verbdir
      done
      cd ${bindir}/../config/kube/exports/cluster-scoped
      # Some are too big to `kubectl apply`
      for rsfn in apiresourceschema-*.yaml; do
	  create_or_replace $rsfn
      done
      for refn in apiexport-*.yaml; do
	  eval kubectl apply -f "$refn" $verbdir
      done
    )
    eval kubectl apply -f - $verbdir <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: compute:apiexport:kubernetes-extended:bind
rules:
- apiGroups:
  - apis.kcp.io
  resourceNames:
  - apps
  - autoscaling
  - batch
  - core.k8s.io
  - discovery.k8s.io
  - networking.k8s.io
  - policy
  - storage.k8s.io
  resources:
  - apiexports
  verbs:
  - bind
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: compute:apiexport:kubernetes:maximal-permission-policy-extended
rules:
- apiGroups:
  - ""
  - apps
  - networking.k8s.io

  - autoscaling
  - batch
  - discovery.k8s.io
  - policy
  - storage.k8s.io
  resources:
  - services
  - pods
  - ingresses
  - deployments

  - cronjobs
  - csistoragecapacities
  - daemonsets
  - endpoints
  - endpointslices
  - horizontalpodautoscalers
  - jobs
  - networkpolicies
  - persistentvolumeclaims
  - poddisruptionbudgets
  - podtemplates
  - replicasets
  - replicationcontrollers
  - statefulsets
  verbs:
  - "*"
- apiGroups:
  - ""
  - apps
  - networking.k8s.io

  - autoscaling
  - batch
  - discovery.k8s.io
  - policy
  - storage.k8s.io
  resources:
  - services/status
  - pods/status
  - ingresses/status
  - deployments/status
  - deployments/scale

  - cronjobs/status
  - csistoragecapacities/status
  - daemonsets/status
  - endpoints/status
  - endpointslices/status
  - horizontalpodautoscalers/status
  - jobs/status
  - networkpolicies/status
  - persistentvolumeclaims/status
  - poddisruptionbudgets/status
  - podtemplates/status
  - replicasets/scale
  - replicasets/status
  - replicationcontrollers/scale
  - replicationcontrollers/status
  - statefulsets/scale
  - statefulsets/status
  verbs:
  - get
  - list
  - watch
  - update
  - patch
EOF
    kubectl apply -f - &> /dev/null <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: compute:apiexport:kubernetes-extended:bind
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: compute:apiexport:kubernetes-extended:bind
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: apis.kcp.io:binding:system:authenticated
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: compute:authenticated:apiexport:kubernetes:maximal-permission-policy-extended
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: compute:apiexport:kubernetes:maximal-permission-policy-extended
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: apis.kcp.io:binding:system:authenticated
EOF
    echo "Finished augmenting root:compute for KubeStellar"
}

 
if [ "$subcommand" != init ]; then

    # Check mailbox-controller is already running
    if [ $(process_running mailbox-controller) == "running" ]
    then
	echo "An older deployment of mailbox-controller is already running - terminating it ...."
	pkill -f mailbox-controller
    fi

    # Check kubestellar-where-resolver is already running
    if [ $(process_running "kubestellar-where-resolver") == "running" ]
    then
	echo "An older deployment of kubestellar-where-resolver is already running - terminating it ...."
	pkill -f "kubestellar-where-resolver"
    fi

    # Check placement-translator is already running
    if [ $(process_running placement-translator) == "running" ]
    then
	echo "An older deployment of placement-translator is already running - terminating it ...."
	pkill -f placement-translator
    fi

fi

if [ $subcommand == stop ]; then
   echo "kubestellar stopped ....."
   exit 0
fi

# Check if kcp is running
if [ "$local_kcp" == true ] && [ $(process_running kcp) != "running" ]; then
    echo "kcp is not running - please start it ...."
    exit 1
fi

let tries=1
while ! ( kubectl get workspaces && kubectl ws root:compute ); do
    if (( ( tries & (tries-1) ) == 0 ))
    then echo "$0: At $(date), kcp server not running yet or root:compute workspace not yet ready, waiting $(( tries * 15 )) sec..." >& 2
    fi
    let tries=tries+1
    sleep 15
done

ensure_root_compute_configd
ensure_espw
ensure_imws $imws
ensure_wmws $wmws
kubectl ws root &> /dev/null

if [ $subcommand == init ]; then
    exit 0
fi

wait_for_process(){
  status=$(process_running $1)
  MAX_RETRIES=5
  retries=0
  status_code=0
  while [ $status != "running" ]; do
      if [ $retries -eq $MAX_RETRIES ]; then
           status_code=1
           break
      fi

      retries=$(( retries + 1 ))
      sleep 3
      status=$(process_running $1)
  done
  echo $status_code
}


# Start the kubestellar controllers
echo "****************************************"
echo "Launching KubeStellar ..."
echo "****************************************"

sleep 5

# Create the logs directory
if [[ ! -d $log_folder ]]; then
    mkdir -p $log_folder
fi

mailbox-controller -v=2 >> $log_folder/mailbox-controller-log.txt 2>&1 &

run_status=$(wait_for_process mailbox-controller)
if [ $run_status -eq 0 ]; then
    echo " mailbox-controller is running (log file: $log_folder/mailbox-controller-log.txt)"
else
    echo " mailbox-controller failed to start ..... exiting"
    sleep 2
    exit 1
fi


# Start the kubestellar where-resolver
sleep 3
kubestellar-where-resolver -v 2 >> $log_folder/kubestellar-where-resolver-log.txt 2>&1 &

run_status=$(wait_for_process "kubestellar-where-resolver")
if [ $run_status -eq 0 ]; then
    echo " where-resolver is running (log file: $log_folder/kubestellar-where-resolver-log.txt)"
else
    echo " where-resolver failed to start ..... exiting"
    exit 1
fi

# Start the Placement Translator
sleep 3
placement-translator --allclusters-context  "system:admin" -v=2 >> $log_folder/placement-translator-log.txt 2>&1 &

run_status=$(wait_for_process placement-translator)
if [ $run_status -eq 0 ]; then
    echo " placement translator is running (log file: $log_folder/placement-translator-log.txt)"
else
    echo " placement translator failed to start ..... exiting"
    exit 1
fi

sleep 10
echo "****************************************"
echo "Finished launching KubeStellar ..."
echo "****************************************"

